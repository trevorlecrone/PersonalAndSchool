import time
import math
import copy
import random
import argparse

#----------------CONSTANTS-----------------------------
PLAYERS = "ABCDEFGHIJKLM"
#used for replay maps too
EMPTY_STATE = {
    "A" : "",
    "B" : "",
    "C" : "",
    "D" : "",
    "E" : "",
    "F" : "",
    "G" : "",
    "H" : "",
    "I" : "",
    "J" : "",
    "K" : "",
    "L" : "",
    "M" : "",
}
#SETUP AND HELPER FUNCTIONS
def create_initial_state() :
    schedule = copy.deepcopy(EMPTY_STATE)
    for player in PLAYERS :
        remaining = PLAYERS.replace(player, "")
        games = ""
        while len(remaining) > 0 :
            i = 4
            while i > 0 :
                gamePlayer = remaining[random.randrange(len(remaining))]
                games = games + gamePlayer
                remaining = remaining.replace(gamePlayer, "")
                i -= 1
            if(len(remaining) > 0) :
                games = games + ":"
        schedule[player] = games
    return schedule

def visualize_state(schedule) :
    for player in PLAYERS :
        games = schedule[player]
        print("Bye for player " + player + ": " + "[" + games.replace(":", "] [") + "]")

def summarize_replays(schedule) :
    replays = copy.deepcopy(EMPTY_STATE)
    for player in PLAYERS :
        games = schedule[player].split(":")
        for player in PLAYERS :
            for game in games :
                if player in game :
                    replays[player] += game.replace(player, "")
    for player in PLAYERS :
        playerReplays = {}
        potentialOpponents = PLAYERS.replace(player, "")
        for opponent in potentialOpponents :
            playerReplays[opponent] = replays[player].count(opponent)
        replays[player] = playerReplays

    return replays

def check_unique_games(schedule) :
    games = []
    for player in PLAYERS :
        games += schedule[player].split(":")
    uniqueGames = set(games)
    if len(games) != len(uniqueGames) :
        return False
    return True

def check_all_players_at_least_once(replays) :
    #small speedup, don't technically need to check M for score when looking at replays
    toCheck = PLAYERS.replace("M", "")
    for player in toCheck :
        playerPlayCounts = list(replays[player].values())
        if 0 in playerPlayCounts :
            return False
    return True

#Gives 4 points whenever a player plays someone 3 times, 2 points for 2 or 4 plays, 0 points for 1 or 5 plays, and subtracts for 6, 7 and 8 proportionally
#Gives steep penalties if a repeat game exists, and if players don't all play one another
def get_state_score(schedule) :
    replays = summarize_replays(schedule)
    score = 0
    #small speedup, don't technically need to check M for score when looking at replays
    toCheck = PLAYERS.replace("M", "")
    for player in toCheck :
        playerPlayCounts = list(replays[player].values())
        for count in playerPlayCounts :
            score += (4 - (abs(3 - count) * 2))
    if not check_all_players_at_least_once(replays) :
        score -= 99999999
    if not check_unique_games(schedule) :
        score -= 99999999
    return score

def getTemperature(initialTemp, iteration) :
   return (initialTemp / float(1.0 + float(iteration / 10))) - 0.01

# SUCCESSOR FUNCTIONS
# Successors are generated by swapping players between 2 games in the same week. Each week has 48 possible swaps
# (since swapping in the same game doesn't matter) for 624 possible successors for a state
def get_random_successor(schedule) :
    result = copy.deepcopy(schedule)
    weekNum = random.randrange(13)
    weekGames = list(result[PLAYERS[weekNum]])
    gamesToSwap = random.sample(range(0,3), 2)
    playersToSwap = random.sample(range(0,4), 2)
    temp = weekGames[gamesToSwap[0] * 5 + playersToSwap[0]]
    weekGames[gamesToSwap[0] * 5 + playersToSwap[0]] = weekGames[gamesToSwap[1] * 5 + playersToSwap[1]]
    weekGames[gamesToSwap[1] * 5 + playersToSwap[1]] = temp
    result[PLAYERS[weekNum]] = "".join(weekGames)
    return result

def get_steepest_successor(schedule) :
    result = copy.deepcopy(schedule)
    score = get_state_score(result)
    for player in PLAYERS :
        weekGames = list(result[player])
        game = 0
        #there is probably a better way to write this, maybe I'll come back to it
        #performs every possible swap, and returns the swap with the best score increase
        while game < 2 :
            playerNum = 0 
            while playerNum <= 3 :
                swapGame = game + 1
                while swapGame <= 2 :
                    swapPlayer = 0
                    while swapPlayer <= 3:
                        swapGameList = copy.deepcopy(weekGames)
                        tempPlayer = swapGameList[game * 5 + playerNum]
                        swapGameList[game * 5 + playerNum] = swapGameList[swapGame * 5 + swapPlayer]
                        swapGameList[swapGame * 5 + swapPlayer] = tempPlayer
                        tempResult = copy.deepcopy(schedule)
                        tempResult[player] = "".join(swapGameList)
                        tempResultScore = get_state_score(tempResult) 
                        if tempResultScore > score :
                            score = tempResultScore
                            result = tempResult
                        swapPlayer += 1
                    swapGame += 1
                playerNum += 1
            game += 1
    return result

#Hill-Climbing steepest ascent
def hill_climb_steepest(state) :
    while True :
        score = get_state_score(state)
        neighbor = get_steepest_successor(state)
        neighborScore = get_state_score(neighbor)
        if neighborScore > score :
            state = neighbor
        else:
            break
    return state

#Simulated Annealing
def simulated_annealing(state) :
    initialTemp = 50
    for x in range(0, 10000) :
        temperature = getTemperature(initialTemp, x)
        if temperature <= 0 :
            return state
        nextState = get_random_successor(state)
        scoreDelta = get_state_score(nextState) - get_state_score(state)
        if scoreDelta > 0 :
            state = nextState
        elif random.random() < math.e ** float(scoreDelta/temperature) :
            state = nextState
    #should never get hit, but here for safety
    return state

parser = argparse.ArgumentParser()
parser.add_argument('--timeSeconds', '-t', help="an integer representing number of seconds EACH algorithm should run for, total runtime will be roughly double", type= int)
args = parser.parse_args()
secondsToRun = args.timeSeconds
if secondsToRun == None :
    secondsToRun = 30

best5 = {
}
t0 = time.time()
while (time.time() - t0 < secondsToRun) :
    state = create_initial_state()
    if len(best5.keys()) == 0 :
        best5[get_state_score(state)] = state
    state = hill_climb_steepest(state)
    stateScore = get_state_score(state)
    if (stateScore > min(list(best5.keys()))) :
        best5[stateScore] = state
    if len(best5.keys()) > 5 :
        del best5[min(list(best5.keys()))]
    
bestState = best5[max(list(best5.keys()))]
print("------------------------------------------------------")
print("Hill Climb steepest ascent with random restart Schedule:")
visualize_state(bestState)
print("Hill Climb steepest ascent with random restart replay summary:")
replays = summarize_replays(bestState)
for player in PLAYERS :
    print(player + ": " + str(replays[player]))

best5 = {
}
t1 = time.time()
while (time.time() - t1 < secondsToRun) :
    state = create_initial_state()
    if len(best5.keys()) == 0 :
        best5[get_state_score(state)] = state
    state = simulated_annealing(state)
    stateScore = get_state_score(state)
    if (stateScore > min(list(best5.keys()))) :
        best5[stateScore] = state
    if len(best5.keys()) > 5 :
        del best5[min(list(best5.keys()))]
    
bestState = best5[max(list(best5.keys()))]
print("------------------------------------------------------")
print("Simulated Annealing Schedule:")
visualize_state(bestState)
print("Simulated Annealing replay summary:")
replays = summarize_replays(bestState)
for player in PLAYERS :
    print(player + ": " + str(replays[player]))


            

